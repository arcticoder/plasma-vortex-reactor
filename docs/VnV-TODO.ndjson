{"category":"V&V","task":"Validate energy-per-antiproton against ≤1e11 J constraint","priority":"High","source_file":"scripts/production_kpi.py","python_snippet":"# Compute E_per_particle from KPI and assert ≤ 1e11 J"}
{"category":"V&V","task":"FOM computation consistency under pair-plasma scenarios","priority":"Medium","source_file":"scripts/production_kpi.py","python_snippet":"# Compare FOM from KPI vs direct metric calculation; assert within tolerance"}
{"category":"V&V","task":"Trap retention validation over 10 ms window","priority":"High","source_file":"scripts/time_to_stability_yield.py","python_snippet":"# Compute retention% in a seeded run and assert >= target threshold"}
{"category":"V&V","task":"Drift-Poisson resolution sensitivity for Bennett profile","priority":"High","source_file":"src/reactor/models.py","source_snippet":"def drift_poisson_step","python_snippet":"import numpy as np\nfrom reactor.models import drift_poisson_step\nomega = np.zeros((64,64)); omega[32,32]=1.0; psi32 = drift_poisson_step(omega, max_iter=50)\nomega2 = np.zeros((128,128)); omega2[64,64]=1.0; psi64 = drift_poisson_step(omega2, max_iter=50)\n# compare norms to ensure convergence behavior"}
{"category":"V&V","task":"Confinement integration smoke: end-to-end Bennett check in Reactor.step","priority":"High","source_file":"src/reactor/core.py","source_snippet":"class Reactor","python_snippet":"from reactor.core import Reactor\nR=Reactor(grid=(32,32), timeline_log_path='progress.ndjson')\nR.xi=2.0; R.b_field_ripple_pct=1e-4; R.step(dt=1e-3);\n# assert timeline contains confinement_achieved if conditions met"}
{"task":"Validate dashboard against malformed anomaly lines","status":"open","notes":"Ensure NDJSON tolerance holds under various corruption patterns.","date":"2025-08-16","priority":"High"}
{"category":"V&V","task":"Yield gate 1e8 cm^-3 s^-1 with physics-based estimator","priority":"High","source_file":"src/reactor/metrics.py","source_snippet":"def antiproton_yield_estimator","python_snippet":"from reactor.metrics import antiproton_yield_estimator as Y\nval = Y(1e20, 1e6, {\"sigma_pp\":1e-25,\"alpha_T\":0.5,\"k0\":1e-10})\nassert val >= 1e8"}
{"category":"V&V","task":"Confinement efficiency 94% under Bennett profile and low ripple","priority":"High","source_file":"src/reactor/metrics.py","source_snippet":"def confinement_efficiency_estimator","python_snippet":"import numpy as np\nfrom reactor.metrics import confinement_efficiency_estimator\nxs = np.linspace(0.5,5.0,10); vals=[confinement_efficiency_estimator(x,0.0001) for x in xs]\nassert np.median(vals) >= 0.94"}
{"category":"V&V","task":"Energy reduction 242x from baseline via enhancements","priority":"Medium","source_file":"src/reactor/energy.py","source_snippet":"class EnergyLedger","python_snippet":"from reactor.energy import EnergyLedger\nL=EnergyLedger(); L.add_power_sample(2.7e9,1.0); L.apply_enhancement(4.2)\nassert L.total_energy() <= 2.7e9/242"}
{"category":"V&V","task":"B-field check: mean>=5T and RMS ripple<=0.01%","priority":"Medium","source_file":"src/reactor/analysis_fields.py","source_snippet":"def b_field_rms_fluctuation","python_snippet":"import numpy as np\nfrom reactor.analysis import b_field_rms_fluctuation\nB=5.0+1e-4*np.random.randn(1000)\nassert b_field_rms_fluctuation(B) <= 1e-4"}
{"category":"V&V","task":"Cooldown cycle logging on thermal overruns","priority":"Medium","source_file":"scripts/timeline_summary.py","source_snippet":"def main","python_snippet":"# Parse timeline.ndjson and assert presence of 'cooldown' events after 'overrun' markers when thermal overrun policy triggers"}
{"category":"V&V","task":"Validate bennett_profile shape and monotonicity","priority":"High","source_file":"src/reactor/models.py","source_snippet":"def bennett_profile","python_snippet":"import numpy as np\nfrom reactor.models import bennett_profile\nr = np.linspace(0,1,128)\nn = bennett_profile(n0=1.0, xi=2.0, r=r)\nassert n.shape == r.shape and np.all(n>0) and n[0] >= n[-1]"}
{"category":"V&V","task":"Check vorticity_evolution conservative behavior without forcing/diffusion","priority":"High","source_file":"src/reactor/models.py","source_snippet":"def vorticity_evolution","python_snippet":"import numpy as np\nfrom reactor.models import vorticity_evolution\nomega = np.zeros((64,64)); psi = np.zeros_like(omega)\nomega_new = vorticity_evolution(omega, psi, nu=0.0, dt=0.01, forcing=None)\nassert np.allclose(omega_new, omega)"}
{"category":"V&V","task":"Drift-Poisson step solves -Δψ=ω within tolerance on a known case","priority":"Medium","source_file":"src/reactor/models.py","source_snippet":"def drift_poisson_step","python_snippet":"import numpy as np\nfrom reactor.models import drift_poisson_step\nomega = np.zeros((32,32)); omega[16,16]=1.0\npsi = drift_poisson_step(omega, max_iter=10)\nassert psi.shape == omega.shape and np.isfinite(psi).all()"}
{"category":"V&V","task":"Microwave Maxwell model preserves dimensionality and responds to σ","priority":"Medium","source_file":"src/reactor/models.py","source_snippet":"def microwave_maxwell","python_snippet":"import numpy as np\nfrom reactor.models import microwave_maxwell\nE = np.ones((16,16,3)); out = microwave_maxwell(E, sigma=1.0, eps_r=2.0, mu_r=1.0, k0=1.0)\nassert out.shape == E.shape and np.all(out < E+1e-6)"}
{"category":"V&V","task":"LG mode generator normalization","priority":"Medium","source_file":"src/reactor/models.py","source_snippet":"def lg_mode","python_snippet":"import numpy as np\nfrom reactor.models import lg_mode\nrho = np.linspace(0,3,200)\nR = lg_mode(n=1,m=2,rho=rho,w=1.0)\nassert R.shape == rho.shape and R.max() <= 1.0+1e-6"}
{"category":"V&V","task":"Kinetics update maintains non-negativity","priority":"High","source_file":"src/reactor/models.py","source_snippet":"def kinetics_update","python_snippet":"import numpy as np\nfrom reactor.models import kinetics_update\nN = np.array([1.0, 0.5]); out = kinetics_update(N, dt=1e-3, rates={})\nassert np.all(out >= 0)"}
{"category":"V&V","task":"Adiabatic invariant μ scales with 1/B","priority":"Medium","source_file":"src/reactor/models.py","source_snippet":"def adiabatic_mu","python_snippet":"import numpy as np\nfrom reactor.models import adiabatic_mu\nmu1 = adiabatic_mu(m=1.0, vc=1.0, B=1.0); mu2 = adiabatic_mu(m=1.0, vc=1.0, B=2.0)\nassert mu2 == mu1/2.0"}
{"category":"V&V","task":"Integration smoke: Reactor.step() updates state","priority":"High","source_file":"src/reactor/core.py","source_snippet":"class Reactor","python_snippet":"from reactor.core import Reactor\nR = Reactor(grid=(32,32)); s0 = R.state.copy(); R.step(dt=1e-3); assert (R.state!=s0).any()"}
{"category":"Docs/Process","task":"Traceability: roadmap tasks appear in UQ/VnV and tests","priority":"High","source_file":"docs/roadmap.ndjson","source_snippet":"associated_tasks","python_snippet":"# Iterate tasks; assert presence in UQ/VnV/TODOs or tests by fuzzy title match"}
{"category":"V&V","task":"Stability Γ computation and 10 ms duration check","priority":"High","source_file":"src/reactor/models.py","source_snippet":"compute_Gamma(omega, rho, p)","python_snippet":"import numpy as np\n# Placeholder: verify stability metric time window logic exists in analysis utilities"}
{"category":"V&V","task":"Yield parser validates ≥1e8 cm^-3 s^-1 when seeded with synthetic data","priority":"High","source_file":"integration: elemental-transmutator","source_snippet":"transmutation_results.json","python_snippet":"import json, numpy as np\n# Load synthetic results and assert threshold met within tolerance"}
{"category":"V&V","task":"Confinement ≥94% under Bennett profile and μ scaling","priority":"Medium","source_file":"src/reactor/models.py","source_snippet":"bennett_profile, adiabatic_mu","python_snippet":"import numpy as np\n# Monte Carlo synthetic B-field ripple; assert efficiency estimator ≥0.94 median"}
{"category":"V&V","task":"Energy_ledger computes E_pbar and matches budget within 5%","priority":"Medium","source_file":"integration: elemental-transmutator","source_snippet":"energy_ledger.py","python_snippet":"# Unit compute E_input, N_pbar; assert E_pbar within target range"}
{"category":"V&V","task":"B-field ≥5 T stability check","priority":"Medium","source_file":"integration: warp-field-coils","source_snippet":"field generator","python_snippet":"# Mock B-field traces and assert <1% RMS fluctuation"}
{"category":"V&V","task":"Plot stability vs ripple from sweep CSV","priority":"Medium","source_file":"scripts/plot_dynamic_stability_ripple.py","source_snippet":"plot_stability_ripple(xs, ys, out)","python_snippet":"# Generate dynamic_stability_ripple.png and assert file exists and size>0"}
{"category":"V&V","task":"High-load hardware metrics plot variant","priority":"Low","source_file":"scripts/plot_hardware_metrics.py","source_snippet":"--high-load","python_snippet":"# Run script with --high-load and assert artifact generated"}
{"category":"V&V","task":"Time and dynamic ripple sweeps produce CSVs","priority":"Medium","source_file":"scripts/param_sweep_confinement.py","source_snippet":"--full-sweep-with-time/--full-sweep-with-dynamic-ripple","python_snippet":"# Run sweeps and validate CSV headers"}
{"category":"V&V","task":"Dual-panel figure generated in CI","priority":"Low","source_file":"scripts/plot_envelope_dual_panel.py","source_snippet":"main","python_snippet":"# Assert envelope_dual_panel.png exists and is non-empty after CI run"}
{"category":"V&V","task":"Frontier JSON schema validity","priority":"Medium","source_file":"scripts/envelope_sweep.py","source_snippet":"--frontier-json","python_snippet":"import json; obj=json.load(open('operating_envelope_frontier.json')); assert 'frontier' in obj and isinstance(obj['frontier'], list)"}
{"category":"V&V","task":"Gamma threshold duration check","priority":"High","source_file":"src/reactor/analysis_stat.py","math_snippet":"\n% require \\Gamma>140 for 10 ms\n","python_snippet":"# Placeholder: assert duration gate logic exists and is exercised in tests"}
{"category":"V&V","task":"NDJSON to CSV exporter handles missing details","priority":"Low","source_file":"scripts/ndjson_to_csv.py","source_snippet":"details flatten","python_snippet":"# Provide NDJSON with/without details; ensure CSV headers match union of keys"}
{"category":"V&V","task":"Seed determinism smoke tests for sweeps and bench","priority":"Medium","source_file":"scripts/envelope_sweep.py","source_snippet":"--seed","python_snippet":"# Run twice with same seed and assert identical JSON outputs"}
